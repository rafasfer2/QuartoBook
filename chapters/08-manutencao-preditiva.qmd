# ManutenÃ§Ã£o Preditiva com Dados Sensor

## IntroduÃ§Ã£o

Uso de dados de sensores e machine learning para prediÃ§Ã£o de falhas.

## PreparaÃ§Ã£o de Dados de Sensores

```{r}
#| label: sensor-data-prep
#| warning: false
#| eval: false

library(tidyverse)
library(lubridate)

# Carregar dados de sensores
sensores <- read_csv("resources/data/sensores_compressor.csv")

# PrÃ©-processamento
sensores_clean <- sensores %>%
  mutate(
    timestamp = ymd_hms(timestamp),
    temp_norm = (temperatura - mean(temperatura)) / sd(temperatura),
    vibr_norm = (vibracao - mean(vibracao)) / sd(vibracao)
  ) %>%
  arrange(equipamento_id, timestamp)

head(sensores_clean)
```

## Feature Engineering

### EstatÃ­sticas em Janela Deslizante

```{r}
#| label: rolling-features
#| eval: false

library(zoo)

# Criar features
sensores_features <- sensores_clean %>%
  group_by(equipamento_id) %>%
  arrange(timestamp) %>%
  mutate(
    temp_mean_7d = rollmean(temperatura, k = 7*24, fill = NA, align = "right"),
    temp_max_7d = rollmax(temperatura, k = 7*24, fill = NA, align = "right"),
    temp_std_7d = rollapply(temperatura, width = 7*24, FUN = sd,
                            fill = NA, align = "right"),
    vibr_trend = c(NA, diff(vibracao))
  ) %>%
  ungroup()
```

## DetecÃ§Ã£o de Anomalias

```{r}
#| label: anomaly-detection
#| warning: false
#| eval: false

library(anomalize)

# DecomposiÃ§Ã£o e detecÃ§Ã£o
anomalias <- sensores_clean %>%
  time_decompose(temperatura, method = "stl") %>%
  anomalize(remainder, method = "iqr") %>%
  time_recompose()

# Visualizar
anomalias %>%
  plot_anomalies(time_recomposed = TRUE) +
  labs(title = "DetecÃ§Ã£o de Anomalias - Temperatura")
```

## Modelo Preditivo com Machine Learning

```{r}
#| label: ml-model
#| warning: false
#| eval: false

library(caret)
library(randomForest)

# Preparar dataset
# Assumir que temos features + label 'falha_proxima'
dados_treino <- sensores_features %>%
  filter(!is.na(temp_mean_7d)) %>%
  select(temp_mean_7d, temp_std_7d, vibr_trend, falha_proxima)

# Dividir treino/teste
set.seed(123)
indices_treino <- createDataPartition(dados_treino$falha_proxima,
                                      p = 0.7, list = FALSE)
treino <- dados_treino[indices_treino, ]
teste <- dados_treino[-indices_treino, ]

# Treinar Random Forest
modelo_rf <- randomForest(falha_proxima ~ .,
                          data = treino,
                          ntree = 100,
                          importance = TRUE)

# PrediÃ§Ã£o
pred_teste <- predict(modelo_rf, teste)

# Matriz de confusÃ£o
confusionMatrix(pred_teste, teste$falha_proxima)
```

## ImportÃ¢ncia de Features

```{r}
#| label: feature-importance
#| eval: false

# Plot importÃ¢ncia
varImpPlot(modelo_rf, main = "ImportÃ¢ncia das VariÃ¡veis")
```

## SÃ©ries Temporais com Prophet

```{r}
#| label: prophet-forecast
#| warning: false
#| eval: false

library(prophet)

# Preparar dados
df_prophet <- sensores_clean %>%
  select(ds = timestamp, y = temperatura)

# Ajustar modelo
m <- prophet(df_prophet, changepoint.prior.scale = 0.05)

# PrevisÃ£o 30 dias
future <- make_future_dataframe(m, periods = 30, freq = "day")
forecast <- predict(m, future)

# Visualizar
plot(m, forecast)
prophet_plot_components(m, forecast)
```

## Threshold DinÃ¢mico

```{r}
#| label: dynamic-threshold
#| eval: false

# Calcular threshold baseado em percentil histÃ³rico
threshold_dinamico <- sensores_clean %>%
  group_by(equipamento_id) %>%
  summarize(
    temp_p95 = quantile(temperatura, 0.95),
    vibr_p95 = quantile(vibracao, 0.95)
  )

# Aplicar alertas
alertas <- sensores_clean %>%
  left_join(threshold_dinamico, by = "equipamento_id") %>%
  filter(temperatura > temp_p95 | vibracao > vibr_p95)
```

## ExercÃ­cios

ğŸ“ **ExercÃ­cio 1**: Implemente detecÃ§Ã£o de anomalias com IQR.

ğŸ“ **ExercÃ­cio 2**: Treine modelo XGBoost e compare com Random Forest.

ğŸ“ **ExercÃ­cio 3**: Crie dashboard Shiny para monitoramento em tempo real.

## Resumo

ğŸ”” **Pontos-chave:**

- Feature engineering Ã© crucial
- DetecÃ§Ã£o de anomalias identifica comportamento anormal
- Machine learning prevÃª falhas antes da ocorrÃªncia
- ManutenÃ§Ã£o preditiva reduz custos e downtime

---

**PrÃ³ximo capÃ­tulo:** Modelos de Confiabilidade de Sistema
