# Manuten칞칚o Preventiva e Otimiza칞칚o de Pol칤ticas

## Introdu칞칚o

Otimiza칞칚o de intervalos de manuten칞칚o preventiva baseada em modelos de confiabilidade.

## Pol칤ticas de Manuten칞칚o

### Manuten칞칚o Baseada em Idade (Age-Based)

Substituir componente quando atinge idade $T_p$.

### Manuten칞칚o Baseada em Uso (Usage-Based)

Substituir ap칩s $N$ ciclos de opera칞칚o.

### Manuten칞칚o Baseada em Condi칞칚o

Monitorar e intervir quando indicadores ultrapassam limites.

## Otimiza칞칚o de Intervalos

### Fun칞칚o Custo

$$
C(T_p) = \frac{C_p R(T_p) + C_f [1 - R(T_p)]}{\int_0^{T_p} R(t) dt}
$$

onde:
- $C_p$ = custo de manuten칞칚o preventiva
- $C_f$ = custo de falha corretiva
- $T_p$ = intervalo preventivo

### Exemplo: Otimiza칞칚o Num칠rica

```{r}
#| label: otimizacao-intervalo
#| warning: false

library(tidyverse)

# Par칙metros Weibull
beta <- 2.5
eta <- 1000

# Custos
C_p <- 1000   # Custo preventiva
C_f <- 5000   # Custo falha

# Fun칞칚o custo esperado
custo_esperado <- function(Tp) {
  R_Tp <- exp(-(Tp/eta)^beta)
  integral <- integrate(function(t) exp(-(t/eta)^beta), 0, Tp)$value

  (C_p * R_Tp + C_f * (1 - R_Tp)) / integral
}

# Avaliar diferentes intervalos
intervalos <- seq(100, 1500, by = 50)
custos <- sapply(intervalos, custo_esperado)

df_opt <- data.frame(intervalo = intervalos, custo = custos)

# Intervalo 칩timo
intervalo_otimo <- intervalos[which.min(custos)]

# Visualizar
ggplot(df_opt, aes(x = intervalo, y = custo)) +
  geom_line(color = "steelblue", linewidth = 1.2) +
  geom_vline(xintercept = intervalo_otimo,
             linetype = "dashed", color = "red") +
  geom_point(data = df_opt[which.min(custos), ],
             color = "red", size = 3) +
  annotate("text", x = intervalo_otimo + 100,
           y = min(custos) + 0.2,
           label = paste("칍timo:", intervalo_otimo, "h"),
           color = "red") +
  labs(title = "Otimiza칞칚o de Intervalo Preventivo",
       x = "Intervalo Tp (horas)",
       y = "Custo Esperado por Hora") +
  theme_minimal()
```

## An치lise de Sensibilidade

```{r}
#| label: sensibilidade

# Variar rela칞칚o de custos
ratios <- c(2, 5, 10, 20)

df_sensibilidade <- expand.grid(
  intervalo = seq(100, 1500, by = 50),
  ratio = ratios
) %>%
  mutate(
    C_p = 1000,
    C_f = C_p * ratio,
    R_Tp = exp(-(intervalo/eta)^beta),
    integral = sapply(intervalo, function(Tp) {
      integrate(function(t) exp(-(t/eta)^beta), 0, Tp)$value
    }),
    custo = (C_p * R_Tp + C_f * (1 - R_Tp)) / integral,
    ratio_label = paste("Cf/Cp =", ratio)
  )

ggplot(df_sensibilidade, aes(x = intervalo, y = custo, color = ratio_label)) +
  geom_line(linewidth = 1) +
  labs(title = "Sensibilidade ao Custo de Falha",
       x = "Intervalo Preventivo (h)",
       y = "Custo Esperado",
       color = "Rela칞칚o de Custos") +
  theme_minimal() +
  theme(legend.position = "top")
```

## Pol칤tica Block vs. Age-Based

### Block Replacement

Todos os componentes substitu칤dos em intervalos fixos.

### Age-Based Replacement

Cada componente substitu칤do individualmente.

```{r}
#| label: block-vs-age
#| eval: false

# Simula칞칚o comparativa
simular_manutencao <- function(n_componentes, tempo_max, politica, ...) {
  # Implementa칞칚o de simula칞칚o
  # ...
}

# Comparar pol칤ticas
resultado_block <- simular_manutencao(100, 10000, "block", Tp = 500)
resultado_age <- simular_manutencao(100, 10000, "age", Tp = 500)
```

## Exerc칤cios

游닇 **Exerc칤cio 1**: Encontre o intervalo 칩timo para seus dados.

游닇 **Exerc칤cio 2**: Fa칞a an치lise de sensibilidade variando .

游닇 **Exerc칤cio 3**: Compare pol칤ticas block vs. age por simula칞칚o.

## Resumo

游댒 **Pontos-chave:**

- Intervalo 칩timo equilibra custos preventivo e corretivo
- An치lise de sensibilidade 칠 crucial
- Diferentes pol칤ticas para diferentes contextos

---

**Pr칩ximo cap칤tulo:** Manuten칞칚o Preditiva com Dados Sensor
